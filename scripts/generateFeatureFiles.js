/* eslint-env node */
import { fileURLToPath } from 'url'
import path, { dirname } from 'path'
import fs from 'fs'

// Recréer __dirname en utilisant import.meta.url
const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const BASE_PATH = process.env.BASE_PATH || '/'
const basePrefix = BASE_PATH === '/' ? '' : BASE_PATH.replace(/\/$/, '')

// Fonction pour parcourir les fichiers .feature
function findFeatureFiles(dir, baseDir, slugIfNoProjects) {
  let results = []

  // Si le dossier n'existe pas, retourner une liste vide
  if (!fs.existsSync(dir)) {
    return results
  }

  fs.readdirSync(dir).forEach((file) => {
    const filePath = path.join(dir, file)
    const stat = fs.statSync(filePath)

    if (stat && stat.isDirectory()) {
      // Récursion pour les sous-dossiers
      results = results.concat(findFeatureFiles(filePath, baseDir, slugIfNoProjects))
    } else if (filePath.endsWith('.feature')) {
      // Générer un chemin relatif basé sur `baseDir`
      const relativePath = '/' + path.relative(baseDir, filePath).replace(/\\/g, '/')
      // Si le chemin ne commence pas par /projects/, et qu'on a un slug fourni,
      // préfixer par /projects/<slug>
      const needsProjectsPrefix = !relativePath.startsWith('/projects/') && !!slugIfNoProjects
      const adjustedRelative = needsProjectsPrefix
        ? `/projects/${slugIfNoProjects}${relativePath}`
        : relativePath
      const fullPath = basePrefix + adjustedRelative
      results.push(fullPath)
    }
  })

  return results
}

function findFeatureSlugs(featureFiles) {
  return [...new Set(
    featureFiles.map((featureFile) => {
      const prefixPattern = basePrefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
      const regex = new RegExp(`^${prefixPattern}/projects/([^/]+)`) // capture le slug après /projects/
      const match = featureFile.match(regex)
      return match ? match[1] : null
    }).filter(slug => slug !== null)
  )]
}

// Fonction pour générer le(s) fichier(s) ts
function generateFiles() {
  // Définir le chemin du répertoire et des fichiers générés
  const outputDirPath = path.join(__dirname, '../src/generated/')
  const featureFilesTsPath = path.join(outputDirPath, 'featureFiles.ts')
  const userConfigTsPath = path.join(outputDirPath, 'userConfig.ts')

  // Vérifier si le répertoire existe, sinon le créer
  if (!fs.existsSync(outputDirPath)) {
    fs.mkdirSync(outputDirPath, { recursive: true })
  }

  const inputDirPath = process.env.FEATURES_DIR
    ? path.resolve(process.env.FEATURES_DIR)
    : path.join(__dirname, '../public/')

  const hasProjectsSubfolder = fs.existsSync(path.join(inputDirPath, 'projects'))
  const slugIfNoProjects = hasProjectsSubfolder ? undefined : path.basename(path.resolve(inputDirPath))

  // 1) Générer les listes de features et slugs
  const featureFiles = findFeatureFiles(inputDirPath, inputDirPath, slugIfNoProjects)
  const featureSlugs = findFeatureSlugs(featureFiles)
  const featureFilesData = '//generated by generate-feature-list plugin\n' +
    'export const FEATURE_FILES = ' + JSON.stringify(featureFiles, null, 2) + '\n\n' +
    'export const FEATURE_SLUGS = ' + JSON.stringify(featureSlugs, null, 2)
  fs.writeFileSync(featureFilesTsPath, featureFilesData)
  console.log(`Feature files list generated: ${featureFilesTsPath}`)

  // 2) Générer un fichier de config utilisateur optionnel (userConfig.ts)
  // Recherche d'un fichier rapports-bdd.config.json au niveau du répertoire des features
  let userTranslations = []
  let userDefaultCategory = null
  let userIgnoredSlugs = []
  try {
    const configJsonPath = path.join(inputDirPath, 'rapports-bdd.config.json')
    if (fs.existsSync(configJsonPath)) {
      const raw = fs.readFileSync(configJsonPath, 'utf-8')
      const parsed = JSON.parse(raw)
      if (parsed && typeof parsed === 'object') {
        if (Array.isArray(parsed.translations)) {
          userTranslations = parsed.translations
        }
        if (typeof parsed.defaultCategory === 'string') {
          userDefaultCategory = parsed.defaultCategory
        }
        if (Array.isArray(parsed.ignoredSlugs)) {
          userIgnoredSlugs = parsed.ignoredSlugs
        }
      }
    }
  } catch (e) {
    console.warn(`[generateFeatureFiles] Warning while reading rapports-bdd.config.json: ${e?.message || e}`)
  }

  const userConfigTs = '//generated by generate-feature-list plugin\n' +
    'export const USER_TRANSLATIONS = ' + JSON.stringify(userTranslations, null, 2) + '\n' +
    'export const USER_DEFAULT_CATEGORY = ' + JSON.stringify(userDefaultCategory) + '\n' +
    'export const USER_IGNORED_SLUGS = ' + JSON.stringify(userIgnoredSlugs, null, 2) + '\n'
  fs.writeFileSync(userConfigTsPath, userConfigTs)
  console.log(`User config generated: ${userConfigTsPath}`)
}

generateFiles()
