/* eslint-env node */
import { fileURLToPath } from 'url'
import path, { dirname } from 'path'
import fs from 'fs'

// Recréer __dirname en utilisant import.meta.url
const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const BASE_PATH = process.env.BASE_PATH || '/'
const basePrefix = BASE_PATH === '/' ? '' : BASE_PATH.replace(/\/$/, '')

// Fonction pour parcourir les fichiers .feature
function findFeatureFiles(dir, baseDir, slugIfNoProjects) {
  let results = []

  // Si le dossier n'existe pas, retourner une liste vide
  if (!fs.existsSync(dir)) {
    return results
  }

  fs.readdirSync(dir).forEach((file) => {
    const filePath = path.join(dir, file)
    const stat = fs.statSync(filePath)

    if (stat && stat.isDirectory()) {
      // Récursion pour les sous-dossiers
      results = results.concat(findFeatureFiles(filePath, baseDir, slugIfNoProjects))
    } else if (filePath.endsWith('.feature')) {
      // Générer un chemin relatif basé sur `baseDir`
      const relativePath = '/' + path.relative(baseDir, filePath).replace(/\\/g, '/')
      // Si le chemin ne commence pas par /projects/, et qu'on a un slug fourni,
      // préfixer par /projects/<slug>
      const needsProjectsPrefix = !relativePath.startsWith('/projects/') && !!slugIfNoProjects
      const adjustedRelative = needsProjectsPrefix
        ? `/projects/${slugIfNoProjects}${relativePath}`
        : relativePath
      const fullPath = basePrefix + adjustedRelative
      results.push(fullPath)
    }
  })

  return results
}

function findFeatureSlugs(featureFiles) {
  return [...new Set(
    featureFiles.map((featureFile) => {
      const prefixPattern = basePrefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
      const regex = new RegExp(`^${prefixPattern}/projects/([^/]+)`) // capture le slug après /projects/
      const match = featureFile.match(regex)
      return match ? match[1] : null
    }).filter(slug => slug !== null)
  )]
}

// Fonction pour générer le fichier ts
function generateFile() {
  // Définir le chemin du répertoire et du fichier
  const outputDirPath = path.join(__dirname, '../src/generated/')
  const outputFilePath = path.join(outputDirPath, 'featureFiles.ts')

  // Vérifier si le répertoire existe, sinon le créer
  if (!fs.existsSync(outputDirPath)) {
    fs.mkdirSync(outputDirPath, { recursive: true })
  }

  const inputDirPath = process.env.FEATURES_DIR
    ? path.resolve(process.env.FEATURES_DIR)
    : path.join(__dirname, '../public/')

  const hasProjectsSubfolder = fs.existsSync(path.join(inputDirPath, 'projects'))
  const slugIfNoProjects = hasProjectsSubfolder ? undefined : path.basename(path.resolve(inputDirPath))

  const featureFiles = findFeatureFiles(inputDirPath, inputDirPath, slugIfNoProjects)
  const featureSlugs = findFeatureSlugs(featureFiles)
  const data = '//generated by generate-feature-list plugin\n' +
    'export const FEATURE_FILES = ' + JSON.stringify(featureFiles, null, 2) + '\n\n' +
    'export const FEATURE_SLUGS = ' + JSON.stringify(featureSlugs, null, 2)
  fs.writeFileSync(outputFilePath, data)
  console.log(`Feature files list generated: ${outputFilePath}`)
}

generateFile()
